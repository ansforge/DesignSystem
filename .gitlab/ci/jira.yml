# Documentation:
#   - Get issue: https://developer.atlassian.com/cloud/jira/platform/rest/v2/api-group-issues/#api-rest-api-2-issue-issueidorkey-get
#   - Issue transition: https://developer.atlassian.com/cloud/jira/platform/rest/v2/api-group-issues/#api-rest-api-2-issue-issueidorkey-transitions-post
#   - Search issue: https://developer.atlassian.com/cloud/jira/platform/rest/v2/api-group-issue-search/#api-rest-api-2-search-post
stages:
  - jira

variables:
  # To be declared inside gitlab-ci > Settings > CI/CD > Variables:
  # JIRA_API_TOKEN
  # JIRA_API_USER
  # GITLAB_API_TOKEN

  # Jira default variables
  JIRA_API_URI: "rest/api/2/"
  JIRA_BASE_URL: "https://URL.kleegroup.com/"
  JIRA_REGEX_ISSUE_ID: '(${JIRA_PROJECT}-[0-9]+)'

  # Jira project variables
  JIRA_ISSUE_DEPLOY_FROM_STATUS: 10501 # Must be "A livrer en recette interne"
  JIRA_ISSUE_DEPLOY_TRANSITION_ID: 641 # From "A livrer en recette interne" to "En test".
  JIRA_ISSUE_MERGE_FROM_STATUS: 10209 # Must be "En revue".
  JIRA_ISSUE_MERGE_TRANSITION_ID: 691 # From "En revue" to "A livrer en recette interne".
  JIRA_PROJECT: "SAN"

#.gitlab_api: &gitlab_api |
#  # List threads on current merge request.
#  function merge_request_list_threads() {
#    local JSON=$(curl -k -X GET -H "PRIVATE-TOKEN:${GITLAB_API_TOKEN}" -H "Content-Type:application/json" --show-error ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes);
#    echo "${JSON}";
#  }
#
#  # Create new thread on current merge request.
#  function merge_request_post_thread() {
#    echo "$1";
#    curl -k -X POST -H "PRIVATE-TOKEN:${GITLAB_API_TOKEN}" -H "Content-Type:application/json" --data "{\"body\":\"$1\"}" --show-error ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/discussions;
#    exit 1;
#  }
#
#  # Create new thread on current merge request if the same unresolved thread does not already exist.
#  function merge_request_post_unique_unresolved_thread() {
#    local JSON=$(merge_request_list_threads);
#    local THREAD=$(echo "${JSON}" | jq -r "map(select(.type == \"DiscussionNote\" and .resolved == false and .body != \"${1}\").id) | @sh");
#
#    if [ -z "$THREAD" ]
#    then
#      merge_request_post_thread "$1"
#    fi
#
#    exit 0;
#  }

#.jira_api: &jira_api |
#  # Search issues from status (parameters: status ID).
#  function search_issues_from_status() {
#    local DATA="{
#        \"jql\":\"project = '${JIRA_PROJECT}' AND status='$1'\",
#        \"fields\":[\"key\"]
#      }"
#    local JSON=$(curl -s -X POST -u "${JIRA_API_USER}:${JIRA_API_TOKEN}" -H "Content-Type:application/json" --data "${DATA}" --show-error ${JIRA_BASE_URL}${JIRA_API_URI}search)
#    echo "${JSON}";
#  }
#
#  # Get issue details
#  function get_issue() {
#    local JSON=$(curl -u "${JIRA_API_USER}:${JIRA_API_TOKEN}" -X GET ${JIRA_BASE_URL}${JIRA_API_URI}issue/${ISSUE_ID})
#    echo "${JSON}";
#  }
#
#  # Update issue status (parameters: issue ID, transition ID, comment).
#  function update_issue_status() {
#    # You can only add a comment while transitioning by REST if you require a comment for transitioning in UI (it not, it's skipped).
#    local DATA="{\"update\":{\"comment\":[{\"add\":{\"body\":\"$3\"}}]},\"transition\":{\"id\":$2}}"
#    # Update issue status on merge.
#    local JSON=$(curl -s -X POST -u "${JIRA_API_USER}:${JIRA_API_TOKEN}" -H "Content-Type:application/json" --data "${DATA}" --show-error ${JIRA_BASE_URL}${JIRA_API_URI}issue/$1/transitions)
#    echo "${JSON}";
#  }

#.jira:basics:
#  image: alpine/curl
#  stage: jira
#  before_script:
#    - *gitlab_api
#    - *jira_api
#    - apk add --update jq && rm -rf /var/cache/apk/*

# ---- Jira ----
#jira:merge_request_check_issue_status:
#  extends:
#    - .jira:basics
#  rules:
#    - !reference [ .git_interne, rules ]
#    - !reference [ .merge_request, rules ]
#  before_script:
#    - ISSUE_ID=$(echo "$CI_MERGE_REQUEST_TITLE" | grep -o -E "$JIRA_REGEX_ISSUE_ID" || true)
#    # Because we are declaring a new "before_script", the one we are extending is no longer called.
#    - !reference [.jira:basics, before_script]
#    - |
#      if [[ -z "$ISSUE_ID" ]]; then
#        merge_request_post_unique_unresolved_thread "Issue key is not defined at the beginning of the merge request title!";
#      fi
#    # Get Jira issue.
#    - JSON=$(get_issue "${ISSUE_ID}")
#    - echo "$JSON"
#    # Define used values.
#    #- ISSUE_TYPE=$(echo "$JSON" | jq -r ".fields.issuetype.id")
#    - STATUS=$(echo "$JSON" | jq -r ".fields.status.id")
#    - STATUS_LABEL=$(echo "$JSON" | jq -r ".fields.status.name")
#  script:
#    - |
#      if [[ "$STATUS" == null ]]
#      then
#        merge_request_post_unique_unresolved_thread "Issue **${ISSUE_ID}** not found or unknown error has occured!";
#      # Check issue is in right status (Jira returns status as a string).
#      elif [[ "${STATUS}" != "${ISSUE_FROM_STATUS}" ]]
#      then
#        merge_request_post_unique_unresolved_thread "Issue [${ISSUE_ID}](${JIRA_BASE_URL}browse/${ISSUE_ID}) is not in the right status (current: **${STATUS_LABEL}**)!";
#      fi
#  allow_failure: true
#  variables:
#    ISSUE_FROM_STATUS: $JIRA_ISSUE_MERGE_FROM_STATUS

#jira:on_merge:
#  extends: .jira:basics
#  rules:
#    - !reference [.git_interne, rules]
#    - if: $CI_COMMIT_BRANCH == "develop"
#  before_script:
#    - ISSUE_ID=$(echo "$CI_MERGE_REQUEST_TITLE" | grep -o -E "$JIRA_REGEX_ISSUE_ID" || true)
#    - |
#      if [[ -z "$ISSUE_ID" ]]; then
#        echo "Issue key is not defined at the beginning of the merge request title!";
#        exit 1;
#      fi
#    # Because we are declaring a new "before_script", the one we are extending is no longer called.
#    - !reference [.jira:basics, before_script]
#  script:
#    - |
#      update_issue_status ${ISSUE_ID} ${TRANSITION_ID} "Merge Request: ${CI_MERGE_REQUEST_PROJECT_URL}/-/merge_requests/${CI_MERGE_REQUEST_IID}"
#  variables:
#    TRANSITION_ID: $JIRA_ISSUE_MERGE_TRANSITION_ID

#jira:on_deployment:
#  extends: .jira:basics
#  rules:
#    - !reference [ .git_interne, rules ]
#    - !reference [ .develop, rules ]
#  before_script:
#    # Because we are declaring a new "before_script", the one we are extending is no longer called.
#    - !reference [.jira:basics, before_script]
#    # Get issues to deploy.
#    - JSON=$(search_issues_from_status ${FROM_STATUS})
#    - ISSUES=$(echo "${JSON}" | jq -r '.issues[].key | @sh' | tr "\n" " " | tr -d \')
#  script:
#    # Update issue status on deployment.
#    - DATA="{\"transition\":{\"id\":$TRANSITION_ID}}"
#    - |
#      for ISSUE_ID in ${ISSUES}
#      do
#        echo "Update Issue: ${ISSUE_ID}"
#        update_issue_status ${ISSUE_ID} ${TRANSITION_ID}
#      done
#  variables:
#    FROM_STATUS: $JIRA_ISSUE_DEPLOY_FROM_STATUS
#    TRANSITION_ID: $JIRA_ISSUE_DEPLOY_TRANSITION_ID